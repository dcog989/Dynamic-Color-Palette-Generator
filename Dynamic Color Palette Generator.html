<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Color Palette Generator</title>
    <style>
        html {
            background: #282828;
        }

        body {
            align-items: center;
            background: #282828;
            box-sizing: border-box;
            color: #cccccc;
            display: flex;
            flex-direction: column;
            font-family: 'Source Code Pro', monospace;
            font-size: 18px;
            margin: 0;
            min-height: 100vh;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
            margin-top: 0;
            text-align: center;
        }

        .controls {
            align-items: flex-end;
            background-color: #3a3a3a;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            padding: 15px;
        }

        .export-controls {
            align-items: center;
            background-color: #3a3a3a;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
            margin-top: 0;
            padding: 15px;
        }


        .control-group {
            border: 1px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            padding: 8px;
        }

        .control-group label {
            color: #ccc;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .controls input[type="number"] {
            appearance: textfield;
            background-color: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #ccc;
            padding: 8px;
            width: 60px;
        }

        .controls .radio-group,
        .export-controls .radio-group {
            align-items: center;
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .controls .radio-group input[type="radio"],
        .export-controls .radio-group input[type="radio"] {
            margin-right: 3px;
            margin-top: 0;
        }

        .controls button,
        .export-controls button {
            background-color: #666;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: .9em;
            padding: 8px 15px;
            transition: background-color 0.2s ease;
        }

        .controls button:hover,
        .export-controls button:hover {
            background-color: #529dcf;
        }

        #palette-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 50px 0 70px;
        }

        .colour-item {
            align-items: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .colour-input {
            appearance: none;
            border: none;
            border: 1px solid #555;
            border-radius: 8px;
            box-sizing: border-box;
            cursor: pointer;
            height: 80px;
            padding: 0;
            width: 120px;
        }

        .colour-input:focus {
            outline: 2px solid #61afef;
            outline-offset: 2px;
        }

        .colour-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .colour-input::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }

        .colour-input::-moz-color-swatch {
            border: none;
            border-radius: 8px;
        }

        .colour-code {
            font-size: 0.9em;
            max-width: 90px;
            text-align: center;
            word-break: break-all;
        }
    </style>
</head>

<body>

    <h1>Dynamic Color Palette Generator</h1>

    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
        <div id="colorPickerContainer"></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="base-hue">Hue (째)</label>
            <input type="number" id="base-hue" value="0" min="0" max="359">
        </div>
        <div class="control-group">
            <label for="base-saturation">Saturation (%)</label>
            <input type="number" id="base-saturation" value="60" min="0" max="100">
        </div>
        <div class="control-group">
            <label for="base-lightness">Lightness (%)</label>
            <input type="number" id="base-lightness" value="75" min="0" max="100">
        </div>
        <div class="control-group">
            <label for="increment-value">Increment by:</label>
            <input type="number" id="increment-value" value="10" min="1" max="360">
        </div>
        <div class="control-group">
            <label>Vary component:</label>
            <div class="radio-group">
                <input type="radio" id="vary-hue" name="vary-param" value="hue" checked>
                <label for="vary-hue">Hue</label>

                <input type="radio" id="vary-saturation" name="vary-param" value="saturation">
                <label for="vary-saturation">Saturation</label>

                <input type="radio" id="vary-lightness" name="vary-param" value="lightness">
                <label for="vary-lightness">Lightness</label>
            </div>
        </div>
        <button id="generate-button">Generate Palette</button>
    </div>

    <div id="palette-container">
    </div>

    <div class="export-controls">
        <div class="control-group">
            <label>Export Format</label>
            <div class="radio-group">
                <input type="radio" id="format-hex" name="export-format" value="hex" checked>
                <label for="format-hex">Hex</label>

                <input type="radio" id="format-hsl" name="export-format" value="hsl">
                <label for="format-hsl">HSL</label>

                <input type="radio" id="format-rgb" name="export-format" value="rgb">
                <label for="format-rgb">RGB</label>
            </div>
        </div>
        <button id="export-button">Export to CSS</button>
        <button id="export-xml-button">Export to XML</button>
    </div>

    <script>
        // Variable to store the generated palette data (HSL values)
        let generatedColors = [];

        // Function to convert HSL to Hexadecimal color code
        // H: Hue (0-360), S: Saturation (0-100), L: Lightness (0-100)
        function hslToHex(h, s, l) {
            // Ensure h is within [0, 360)
            h = h % 360;
            if (h < 0) {
                h += 360;
            }

            // Convert s and l to be within [0, 1]
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }

            // Convert RGB [0, 1] to [0, 255] and round
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            // Convert RGB to Hex string
            const toHex = (c) => {
                const hex = c.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        // Function to convert HSL to RGB object (0-255)
        // H: Hue (0-360), S: Saturation (0-100), L: Lightness (0-100)
        function hslToRgb(h, s, l) {
            // Ensure h is within [0, 360)
            h = h % 360;
            if (h < 0) {
                h += 360;
            }

            // Convert s and l to be within [0, 1]
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;

            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }

            // Convert RGB [0, 1] to [0, 255] and round
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return { r: r, g: g, b: b };
        }


        // Helper function to create and append a single swatch item
        function createSwatch(h, s, l, hexColor, container) {
            // Create the container div for a single colour item (swatch + hex code)
            const colourItem = document.createElement('div');
            colourItem.classList.add('colour-item');

            // Create the <input type="color"> element for the swatch
            const colourInput = document.createElement('input');
            colourInput.type = 'color';
            colourInput.classList.add('colour-input');
            colourInput.value = hexColor; // Set the swatch colour
            // Add a title attribute for a helpful tooltip on hover with HSL and Hex values
            colourInput.title = `HSL(${h}째, ${s}%, ${l}%) - ${hexColor}`;

            // Create the div to display the hex code text
            const colourCode = document.createElement('div');
            colourCode.classList.add('colour-code');
            colourCode.textContent = hexColor; // Set the text content to the hex code
            colourCode.style.color = hexColor; // Set the text colour to match the swatch colour

            // Append the input swatch and the hex code div to their container
            colourItem.appendChild(colourInput);
            colourItem.appendChild(colourCode);

            // Append the complete colour item to the main palette container
            container.appendChild(colourItem);
        }


        // Function to generate and display the colour palette based on inputs
        function generatePalette() {
            // Get input elements
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const paletteContainer = document.getElementById('palette-container');

            // Get current values from inputs
            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue'; // Default to varying Hue
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }

            // Basic validation of input values
            if (isNaN(baseH) || baseH < 0 || baseH > 359) {
                alert('Please enter a valid Base Hue (0-359).');
                baseHueInput.focus();
                return;
            }
            if (isNaN(baseS) || baseS < 0 || baseS > 100) {
                alert('Please enter a valid Base Saturation (0-100).');
                baseSaturationInput.focus();
                return;
            }
            if (isNaN(baseL) || baseL < 0 || baseL > 100) {
                alert('Please enter a valid Base Lightness (0-100).');
                baseLightnessInput.focus();
                return;
            }
            // Max increment depends on the varying parameter, but 360 is a safe upper bound for the input field
            if (isNaN(increment) || increment < 1) {
                alert('Please enter a valid Increment Value (1 or greater).');
                incrementValueInput.focus();
                return;
            }
            if (varyParam === 'hue' && increment > 360) {
                alert('Hue Increment cannot exceed 360.');
                incrementValueInput.focus();
                return;
            }
            if ((varyParam === 'saturation' || varyParam === 'lightness') && increment > 100) {
                alert('Saturation or Lightness Increment cannot exceed 100.');
                incrementValueInput.focus();
                return;
            }


            // Clear any previously generated palette items and stored data
            paletteContainer.innerHTML = '';
            generatedColors = []; // Clear the stored palette data

            // Generate colours based on the selected varying parameter
            let palette = [];
            if (varyParam === 'hue') {
                // Calculate increments up and down from baseH
                let hues = new Set();
                hues.add(baseH);
                // Up
                for (let h = baseH + increment; h < 360; h += increment) {
                    hues.add(h);
                }
                // Down
                for (let h = baseH - increment; h >= 0; h -= increment) {
                    hues.add(h);
                }
                palette = Array.from(hues).map(h => ({ h, s: baseS, l: baseL }));
                palette.sort((a, b) => a.h - b.h);
            } else if (varyParam === 'saturation') {
                let sats = new Set();
                sats.add(baseS);
                for (let s = baseS + increment; s <= 100; s += increment) {
                    sats.add(s);
                }
                for (let s = baseS - increment; s >= 0; s -= increment) {
                    sats.add(s);
                }
                palette = Array.from(sats).map(s => ({ h: baseH, s, l: baseL }));
                palette.sort((a, b) => a.s - b.s);
            } else if (varyParam === 'lightness') {
                let lights = new Set();
                lights.add(baseL);
                for (let l = baseL + increment; l <= 100; l += increment) {
                    lights.add(l);
                }
                for (let l = baseL - increment; l >= 0; l -= increment) {
                    lights.add(l);
                }
                palette = Array.from(lights).map(l => ({ h: baseH, s: baseS, l }));
                palette.sort((a, b) => a.l - b.l);
            }
            // Store and display
            generatedColors = palette;
            for (const color of palette) {
                const hexColor = hslToHex(color.h, color.s, color.l);
                createSwatch(color.h, color.s, color.l, hexColor, paletteContainer);
            }
        }

        // Function to export the generated palette as a CSS file
        function exportCssPalette() {
            // Check if a palette has been generated
            if (generatedColors.length === 0) {
                alert("Generate a palette first!");
                return;
            }

            // Get current input values to include in the comment
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const exportFormatRadios = document.querySelectorAll('input[name="export-format"]');

            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue';
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }

            let exportFormat = 'hex';
            for (const radio of exportFormatRadios) {
                if (radio.checked) {
                    exportFormat = radio.value;
                    break;
                }
            }

            // Construct the comment string describing the palette
            let varyingParameter = varyParam.charAt(0).toUpperCase() + varyParam.slice(1); // Capitalise first letter
            let unit = '';
            if (varyParam === 'hue') {
                unit = '째';
            } else if (varyParam === 'saturation' || varyParam === 'lightness') {
                unit = '%';
            }

            const comment = `/*\n * Palette of colors based on HSL(${baseH} ${baseS}% ${baseL}%)\n * Varying on ${varyingParameter}, in increments of ${increment}${unit}\n * Exported as ${exportFormat.toUpperCase()}\n */\n\n`;


            let cssContent = comment + ':root {\n'; // Prepend comment and start the :root block in CSS

            // Iterate through the stored colour data
            generatedColors.forEach((color, index) => {
                // Format the CSS variable name --color-NN, padded with leading zeros
                // Use padStart(3, '0') for numbers up to 999 (handles palettes up to 360 colours)
                const varName = `--color-${String(index + 1).padStart(3, '0')}`;

                let colorValueString = '';
                if (exportFormat === 'hex') {
                    // Convert HSL to Hex for export
                    colorValueString = hslToHex(color.h, color.s, color.l);
                } else if (exportFormat === 'hsl') {
                    // Use stored HSL format
                    colorValueString = `hsl(${color.h} ${color.s}% ${color.l}%)`;
                } else if (exportFormat === 'rgb') {
                    // Convert HSL to RGB and format as rgb(r, g, b)
                    const rgb = hslToRgb(color.h, color.s, color.l);
                    colorValueString = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                }

                // Add the variable definition to the CSS content string with indentation
                cssContent += `  ${varName}: ${colorValueString};\n`;
            });

            cssContent += '}'; // Close the :root block

            // Create a Blob containing the CSS string
            const blob = new Blob([cssContent], { type: 'text/css' });

            // Create a temporary anchor element for the download
            const a = document.createElement('a');

            // Create a URL for the blob using the browser's createObjectURL method
            a.href = URL.createObjectURL(blob);

            // Set the download attribute with the desired filename in 'Palette yymmddHHMM.css' format
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const y = now.getFullYear().toString().slice(-2);
            const m = pad(now.getMonth() + 1);
            const d = pad(now.getDate());
            const H = pad(now.getHours());
            const M = pad(now.getMinutes());
            a.download = `Palette ${y}${m}${d}${H}${M}.css`;

            // Append the link to the body (required for some browsers like Firefox to trigger click)
            document.body.appendChild(a);

            // Programmatically click the link to trigger the download
            a.click();

            // Clean up: remove the temporary link element from the DOM
            // and revoke the object URL to free up memory.
            // Use a short timeout to ensure the download action is initiated before cleanup.
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100); // 100ms delay for cleanup

        }

        // Function to export the generated palette as an XML file
        function exportXmlPalette() {
            if (generatedColors.length === 0) {
                alert("Generate a palette first!");
                return;
            }
            const baseHueInput = document.getElementById('base-hue');
            const baseSaturationInput = document.getElementById('base-saturation');
            const baseLightnessInput = document.getElementById('base-lightness');
            const incrementValueInput = document.getElementById('increment-value');
            const varyParamRadios = document.querySelectorAll('input[name="vary-param"]');
            const exportFormatRadios = document.querySelectorAll('input[name="export-format"]');

            const baseH = parseInt(baseHueInput.value);
            const baseS = parseInt(baseSaturationInput.value);
            const baseL = parseInt(baseLightnessInput.value);
            const increment = parseInt(incrementValueInput.value);

            let varyParam = 'hue';
            for (const radio of varyParamRadios) {
                if (radio.checked) {
                    varyParam = radio.value;
                    break;
                }
            }
            let exportFormat = 'hex';
            for (const radio of exportFormatRadios) {
                if (radio.checked) {
                    exportFormat = radio.value;
                    break;
                }
            }
            let varyingParameter = varyParam.charAt(0).toUpperCase() + varyParam.slice(1);
            let unit = '';
            if (varyParam === 'hue') {
                unit = '째';
            } else if (varyParam === 'saturation' || varyParam === 'lightness') {
                unit = '%';
            }
            let xmlContent = `<?xml version="1.0" encoding="UTF-8"?>\n<!--\n    Palette of colors based on HSL(${baseH} ${baseS}% ${baseL}%)\n    Varying on ${varyingParameter}, in increments of ${increment}${unit}\n    Exported as ${exportFormat.toUpperCase()}\n-->\n<Palette>\n\n`;
            generatedColors.forEach((color, index) => {
                let valueAttr = '';
                let attrName = '';
                if (exportFormat === 'hex') {
                    valueAttr = hslToHex(color.h, color.s, color.l);
                    attrName = 'hexvalue';
                } else if (exportFormat === 'hsl') {
                    valueAttr = `hsl(${color.h} ${color.s}% ${color.l}%)`;
                    attrName = 'hslvalue';
                } else if (exportFormat === 'rgb') {
                    const rgb = hslToRgb(color.h, color.s, color.l);
                    valueAttr = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    attrName = 'rgbvalue';
                }
                let name = `color${String(index + 1).padStart(2, '0')}`;
                xmlContent += `    <myColor ${attrName}=\"${valueAttr}\" name=\"${name}\" />\n`;
            });
            xmlContent += "\n</Palette>";
            const blob = new Blob([xmlContent], { type: 'application/xml' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const y = now.getFullYear().toString().slice(-2);
            const m = pad(now.getMonth() + 1);
            const d = pad(now.getDate());
            const H = pad(now.getHours());
            const M = pad(now.getMinutes());
            a.download = `palette ${y}${m}${d}${H}${M}.xml`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100);
        }

        // Initialize iro.js color picker
        let colorPicker;
        document.addEventListener('DOMContentLoaded', () => {
            generatePalette(); // Call the function to generate the initial palette

            // Get references to the buttons after the DOM is fully loaded
            const generateButton = document.getElementById('generate-button');
            const exportButton = document.getElementById('export-button');
            const exportXmlButton = document.getElementById('export-xml-button');

            // Add event listeners to the buttons
            generateButton.addEventListener('click', generatePalette);
            exportButton.addEventListener('click', exportCssPalette); // Add listener for the export button
            exportXmlButton.addEventListener('click', exportXmlPalette); // Add listener for the export XML button

            colorPicker = new iro.ColorPicker('#colorPickerContainer', {
                width: 220,
                color: { h: 0, s: 60, l: 75 },
                layout: 'default',
            });
            colorPicker.on('color:change', function (color) {
                document.getElementById('base-hue').value = Math.round(color.hsl.h);
                document.getElementById('base-saturation').value = Math.round(color.hsl.s);
                document.getElementById('base-lightness').value = Math.round(color.hsl.l);
            });

            // Sync color picker when HSL inputs change
            const hInput = document.getElementById('base-hue');
            const sInput = document.getElementById('base-saturation');
            const lInput = document.getElementById('base-lightness');
            function updateColorPickerFromInputs() {
                const h = parseInt(hInput.value);
                const s = parseInt(sInput.value);
                const l = parseInt(lInput.value);
                if (!isNaN(h) && !isNaN(s) && !isNaN(l)) {
                    colorPicker.color.hsl = { h, s, l };
                }
            }
            hInput.addEventListener('input', updateColorPickerFromInputs);
            sInput.addEventListener('input', updateColorPickerFromInputs);
            lInput.addEventListener('input', updateColorPickerFromInputs);
        });

    </script>

    <!-- Color Picker -->
    <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>

</body>

</html>